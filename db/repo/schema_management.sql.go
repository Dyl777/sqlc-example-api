// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: schema_management.sql

package repo

import (
	"context"
)

const createTableSchema = `-- name: CreateTableSchema :one
INSERT INTO table_schema (table_name, schema_version, field_definitions, is_active)
VALUES ($1, $2, $3, $4)
RETURNING id, table_name, schema_version, field_definitions, is_active, created_at
`

type CreateTableSchemaParams struct {
	TableName        string `json:"table_name"`
	SchemaVersion    int32  `json:"schema_version"`
	FieldDefinitions []byte `json:"field_definitions"`
	IsActive         *bool  `json:"is_active"`
}

func (q *Queries) CreateTableSchema(ctx context.Context, arg CreateTableSchemaParams) (TableSchema, error) {
	row := q.db.QueryRow(ctx, createTableSchema,
		arg.TableName,
		arg.SchemaVersion,
		arg.FieldDefinitions,
		arg.IsActive,
	)
	var i TableSchema
	err := row.Scan(
		&i.ID,
		&i.TableName,
		&i.SchemaVersion,
		&i.FieldDefinitions,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateOldSchemas = `-- name: DeactivateOldSchemas :exec
UPDATE table_schema 
SET is_active = false
WHERE table_name = $1 AND schema_version < $2
`

type DeactivateOldSchemasParams struct {
	TableName     string `json:"table_name"`
	SchemaVersion int32  `json:"schema_version"`
}

func (q *Queries) DeactivateOldSchemas(ctx context.Context, arg DeactivateOldSchemasParams) error {
	_, err := q.db.Exec(ctx, deactivateOldSchemas, arg.TableName, arg.SchemaVersion)
	return err
}

const getTableSchema = `-- name: GetTableSchema :one
SELECT id, table_name, schema_version, field_definitions, is_active, created_at FROM table_schema
WHERE table_name = $1 AND is_active = true
ORDER BY schema_version DESC
LIMIT 1
`

func (q *Queries) GetTableSchema(ctx context.Context, tableName string) (TableSchema, error) {
	row := q.db.QueryRow(ctx, getTableSchema, tableName)
	var i TableSchema
	err := row.Scan(
		&i.ID,
		&i.TableName,
		&i.SchemaVersion,
		&i.FieldDefinitions,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getTableSchemaByVersion = `-- name: GetTableSchemaByVersion :one
SELECT id, table_name, schema_version, field_definitions, is_active, created_at FROM table_schema
WHERE table_name = $1 AND schema_version = $2
`

type GetTableSchemaByVersionParams struct {
	TableName     string `json:"table_name"`
	SchemaVersion int32  `json:"schema_version"`
}

func (q *Queries) GetTableSchemaByVersion(ctx context.Context, arg GetTableSchemaByVersionParams) (TableSchema, error) {
	row := q.db.QueryRow(ctx, getTableSchemaByVersion, arg.TableName, arg.SchemaVersion)
	var i TableSchema
	err := row.Scan(
		&i.ID,
		&i.TableName,
		&i.SchemaVersion,
		&i.FieldDefinitions,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const listTableSchemas = `-- name: ListTableSchemas :many
SELECT id, table_name, schema_version, field_definitions, is_active, created_at FROM table_schema
WHERE table_name = $1
ORDER BY schema_version DESC
`

func (q *Queries) ListTableSchemas(ctx context.Context, tableName string) ([]TableSchema, error) {
	rows, err := q.db.Query(ctx, listTableSchemas, tableName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableSchema{}
	for rows.Next() {
		var i TableSchema
		if err := rows.Scan(
			&i.ID,
			&i.TableName,
			&i.SchemaVersion,
			&i.FieldDefinitions,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTableSchema = `-- name: UpdateTableSchema :one
UPDATE table_schema 
SET field_definitions = $3, is_active = $4
WHERE table_name = $1 AND schema_version = $2
RETURNING id, table_name, schema_version, field_definitions, is_active, created_at
`

type UpdateTableSchemaParams struct {
	TableName        string `json:"table_name"`
	SchemaVersion    int32  `json:"schema_version"`
	FieldDefinitions []byte `json:"field_definitions"`
	IsActive         *bool  `json:"is_active"`
}

func (q *Queries) UpdateTableSchema(ctx context.Context, arg UpdateTableSchemaParams) (TableSchema, error) {
	row := q.db.QueryRow(ctx, updateTableSchema,
		arg.TableName,
		arg.SchemaVersion,
		arg.FieldDefinitions,
		arg.IsActive,
	)
	var i TableSchema
	err := row.Scan(
		&i.ID,
		&i.TableName,
		&i.SchemaVersion,
		&i.FieldDefinitions,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}
